//
//  a2_video.cpp
//  FAE_SDL
//
//  Created by Frederic Stark on 30/05/16.
//  Copyright (c) 2016 Fred. All rights reserved.
//

#include "a2_video.hpp"
#include <cassert>

//	TEXT RENDERING

//	4 columns of 8x8 chars, columns first
//	@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_ !\"#$%&'()*+,-./0123456789:;<=>?
static const byte apple2font_bits[] = {
	0x00, 0x00, 0x00, 0x00, 0x1C, 0x1E, 0x00, 0x1C, 0x22, 0x22, 0x00, 0x22,
	0x2A, 0x22, 0x00, 0x32, 0x3A, 0x1E, 0x00, 0x2A, 0x1A, 0x02, 0x00, 0x26,
	0x02, 0x02, 0x00, 0x22, 0x3C, 0x02, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00,
	0x08, 0x1C, 0x08, 0x08, 0x14, 0x22, 0x08, 0x0C, 0x22, 0x22, 0x08, 0x08,
	0x22, 0x22, 0x08, 0x08, 0x3E, 0x2A, 0x08, 0x08, 0x22, 0x12, 0x00, 0x08,
	0x22, 0x2C, 0x08, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x1E, 0x14, 0x1C,
	0x22, 0x22, 0x14, 0x22, 0x22, 0x22, 0x14, 0x20, 0x1E, 0x1E, 0x00, 0x18,
	0x22, 0x0A, 0x00, 0x04, 0x22, 0x12, 0x00, 0x02, 0x1E, 0x22, 0x00, 0x3E,
	0x00, 0x00, 0x00, 0x00, 0x1C, 0x1C, 0x14, 0x3E, 0x22, 0x22, 0x14, 0x20,
	0x02, 0x02, 0x3E, 0x10, 0x02, 0x1C, 0x14, 0x18, 0x02, 0x20, 0x3E, 0x20,
	0x22, 0x22, 0x14, 0x22, 0x1C, 0x1C, 0x14, 0x1C, 0x00, 0x00, 0x00, 0x00,
	0x1E, 0x3E, 0x08, 0x10, 0x22, 0x08, 0x3C, 0x18, 0x22, 0x08, 0x0A, 0x14,
	0x22, 0x08, 0x1C, 0x12, 0x22, 0x08, 0x28, 0x3E, 0x22, 0x08, 0x1E, 0x10,
	0x1E, 0x08, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x22, 0x06, 0x3E,
	0x02, 0x22, 0x26, 0x02, 0x02, 0x22, 0x10, 0x1E, 0x1E, 0x22, 0x08, 0x20,
	0x02, 0x22, 0x04, 0x20, 0x02, 0x22, 0x32, 0x22, 0x3E, 0x1C, 0x30, 0x1C,
	0x00, 0x00, 0x00, 0x00, 0x3E, 0x22, 0x04, 0x38, 0x02, 0x22, 0x0A, 0x04,
	0x02, 0x22, 0x0A, 0x02, 0x1E, 0x22, 0x04, 0x1E, 0x02, 0x22, 0x2A, 0x22,
	0x02, 0x14, 0x12, 0x22, 0x02, 0x08, 0x2C, 0x1C, 0x00, 0x00, 0x00, 0x00,
	0x3C, 0x22, 0x08, 0x3E, 0x02, 0x22, 0x08, 0x20, 0x02, 0x22, 0x08, 0x10,
	0x02, 0x2A, 0x00, 0x08, 0x32, 0x2A, 0x00, 0x04, 0x22, 0x36, 0x00, 0x04,
	0x3C, 0x22, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x22, 0x22, 0x08, 0x1C,
	0x22, 0x22, 0x04, 0x22, 0x22, 0x14, 0x02, 0x22, 0x3E, 0x08, 0x02, 0x1C,
	0x22, 0x14, 0x02, 0x22, 0x22, 0x22, 0x04, 0x22, 0x22, 0x22, 0x08, 0x1C,
	0x00, 0x00, 0x00, 0x00, 0x1C, 0x22, 0x08, 0x1C, 0x08, 0x22, 0x10, 0x22,
	0x08, 0x14, 0x20, 0x22, 0x08, 0x08, 0x20, 0x3C, 0x08, 0x08, 0x20, 0x20,
	0x08, 0x08, 0x10, 0x10, 0x1C, 0x08, 0x08, 0x0E, 0x00, 0x00, 0x00, 0x00,
	0x20, 0x3E, 0x08, 0x00, 0x20, 0x20, 0x2A, 0x00, 0x20, 0x10, 0x1C, 0x08,
	0x20, 0x08, 0x08, 0x00, 0x20, 0x04, 0x1C, 0x08, 0x22, 0x02, 0x2A, 0x00,
	0x1C, 0x3E, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x3E, 0x00, 0x00,
	0x12, 0x06, 0x08, 0x00, 0x0A, 0x06, 0x08, 0x08, 0x06, 0x06, 0x3E, 0x00,
	0x0A, 0x06, 0x08, 0x08, 0x12, 0x06, 0x08, 0x08, 0x22, 0x3E, 0x00, 0x04,
	0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x10, 0x02, 0x02, 0x00, 0x08,
	0x02, 0x04, 0x00, 0x04, 0x02, 0x08, 0x00, 0x02, 0x02, 0x10, 0x08, 0x04,
	0x02, 0x20, 0x08, 0x08, 0x3E, 0x00, 0x04, 0x10, 0x00, 0x00, 0x00, 0x00,
	0x22, 0x3E, 0x00, 0x00, 0x36, 0x30, 0x00, 0x00, 0x2A, 0x30, 0x00, 0x3E,
	0x2A, 0x30, 0x3E, 0x00, 0x22, 0x30, 0x00, 0x3E, 0x22, 0x30, 0x00, 0x00,
	0x22, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x04,
	0x22, 0x00, 0x00, 0x08, 0x26, 0x08, 0x00, 0x10, 0x2A, 0x14, 0x00, 0x20,
	0x32, 0x22, 0x00, 0x10, 0x22, 0x00, 0x00, 0x08, 0x22, 0x00, 0x08, 0x04,
	0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x1C, 0x22, 0x00, 0x20, 0x22,
	0x22, 0x00, 0x10, 0x10, 0x22, 0x00, 0x08, 0x08, 0x22, 0x00, 0x04, 0x08,
	0x22, 0x00, 0x02, 0x00, 0x1C, 0x7F, 0x00, 0x08,
};

typedef enum
{   kNormal,
	kInverted,
	kFlashing
} eStyle;

//	Copies one scan line of text
static void text_scan_cpy(byte* const dest, const byte* const src, const int char_offset, const bool inverted)
{
	auto p      = src;
	uint32_t* q = (uint32_t*)dest;
	for (int x = 0; x != 40; x++)
	{
		char c = *p++;

		eStyle style;
		switch (c & 0xc0)
		{
			case 0x00:
				style = kInverted;
				break;
			case 0x40:
				style = kFlashing;
				break;
			default:
				style = kNormal;
				break;
		}

		if (style == kFlashing)
		{
            style = inverted?kInverted:kNormal;
		}

		c &= 0x3f;

		byte b = apple2font_bits[((c & 0xf) << 5) + (c >> 4) + char_offset * 4];

		for (int x = 0; x != 7; x++)
		{
			*q++ = ((b & 0x1) ^ (style == kInverted)) ? 0xff40ff40 : 0xff000000;
			b >>= 1;
		}
	}
}

static uint32_t gr_color(const int color)
{
	auto c                      = color;
	static const int rgb[16][3] = {
		{ 0x00, 0x00, 0x00 }, //	BLACK
		{ 0xdd, 0x00, 0x33 }, //	"MAGENTA"
		{ 0x00, 0x00, 0x99 }, //	DARK BLUE
		{ 0xdd, 0x22, 0xdd }, //	PURPLE
		{ 0x00, 0x77, 0x22 }, //	DARK GREEN
		{ 0x55, 0x55, 0x55 }, //	GREY 1 (DARK)
		{ 0x22, 0x22, 0xff }, //	MEDIUM BLUE
		{ 0x66, 0xaa, 0xff }, //	LIGHT BLUE

		{ 0x88, 0x55, 0x00 }, //	BROWN
		{ 0xff, 0x66, 0x00 }, //	ORANGE
		{ 0xaa, 0xaa, 0xaa }, //	GREY 2 (LIGHT)
		{ 0xff, 0x99, 0x88 }, //	PINK
		{ 0x11, 0xdd, 0x00 }, //	LIGHT GREEN
		{ 0xff, 0xff, 0x00 }, //	YELLOW
		{ 0x44, 0xff, 0x99 }, //	AQUAMARINE
		{ 0xff, 0xff, 0xff }, //	WHITE
	};
	c &= 0xf;
	return (rgb[c][2] << 16) + (rgb[c][1] << 8) + rgb[c][0];
}

static void gr_scan_cpy(byte* const dest, const byte* const src, const bool high)
{
	uint32_t* q = (uint32_t*)dest;
	auto p      = src;
	for (int x = 0; x != 40; x++)
	{
		byte b = *p++;
		int c  = b >> (high * 4);
		for (int i = 0; i != 7; i++)
			*q++ = gr_color(c);
	}
}

static int text_offset(const int line)
{
	static const word offsets[24] = {
		0x000, 0x080, 0x100, 0x180, 0x200, 0x280, 0x300, 0x380,
		0x028, 0x0A8, 0x128, 0x1A8, 0x228, 0x2A8, 0x328, 0x3A8,
		0x050, 0x0D0, 0x150, 0x1D0, 0x250, 0x2D0, 0x350, 0x3D0
	};

	return offsets[line];
}

//	HIRES RENDERING

static int hires_offset(const int y)
{
	auto h = y;
	auto l = h & 0x7;
	h >>= 3;

	auto m = h & 0x7;
	h >>= 3;

	return h * 0x28 + m * 0x80 + l * 0x400;
}

static int mix(const int a, const int b)
{
	auto r = a + b;
	if (r > 255)
		r = 255;
	return r;
}

static void hires_scan_cpy(byte* const dst, const byte* const src)
{

	int last_color = 0;

	//	black, black, violet, green, black, black, blue, orange
	static const int red[8]   = { 0, 0, 255, 0, 0, 0, 0, 255 };
	static const int green[8] = { 0, 0, 0, 255, 0, 0, 128, 127 };
	static const int blue[8]  = { 0, 0, 255, 0, 0, 0, 255, 0 };

	auto q = dst;
	auto p = src;

	for (int x = 0; x != 40; x++)
	{
		auto b = *p++;

		const int type = (b & 0x80) >> 5; //	Type of byte (violet/green vs blue/orange)

		for (int i = 0; i != 7; i++)
		{
			const auto new_color = ((b & 0x1) << 1) | ((i & 0x1) ^ (x & 0x1)) | type;

			*q++ = mix(blue[last_color], blue[new_color]);
			*q++ = mix(green[last_color], green[new_color]);
			*q++ = mix(red[last_color], red[new_color]);
			*q++ = 0xff;

			last_color = new_color;
			b >>= 1;
		}
	}
}

void a2_video::draw(byte* const image, const long frame)
{
	const int base_hires = 0x2000 + is_page2() * 0x2000;
	const int base_text  = 0x0400 + is_page2() * 0x400;

	const byte* hires = memory_.dma_read(base_hires, 0x2000);
	const byte* text  = memory_.dma_read(base_text, 0x0400);

	assert(hires);
	assert(text);

	auto p = image;

	if (is_text())
		for (int y = 0; y != HGRMH; y++, p += HGRW * 4)
			text_scan_cpy(p, text + text_offset(y / 8), y & 0x7, (frame % 50 < 25));
	else if (is_hires())
		for (int y = 0; y != HGRMH; y++, p += HGRW * 4)
			hires_scan_cpy(p, hires + hires_offset(y));
	else
		for (int y = 0; y != HGRMH; y++, p += HGRW * 4)
			gr_scan_cpy(p, text + text_offset(y / 8), (y & 0x04) == 0x04);

	if (is_text() || is_mixed())
		for (int y = HGRMH; y != HGRH; y++, p += HGRW * 4)
			text_scan_cpy(p, text + text_offset(y / 8), y & 0x7, (frame % 50 < 25));
	else if (is_hires())
		for (int y = HGRMH; y != HGRH; y++, p += HGRW * 4)
			hires_scan_cpy(p, hires + hires_offset(y));
	else
		for (int y = HGRMH; y != HGRH; y++, p += HGRW * 4)
			gr_scan_cpy(p, text + text_offset(y / 8), (y & 0x04) == 0x04);
}
